//-----------------------------------------------------------------//
// Name        | Ccambuf.h                   | Type: ( ) source    //
//-------------------------------------------|       (*) header    //
// Project     | pco.camera                  |       ( ) others    //
//-----------------------------------------------------------------//
// Platform    | Linux                                             //
//-----------------------------------------------------------------//
// Environment |                                                   //
//             |                                                   //
//-----------------------------------------------------------------//
// Purpose     | pco.camera - buffer class functions               //
//-----------------------------------------------------------------//
// Author      | MBL, PCO AG                                       //
//-----------------------------------------------------------------//
// Revision    | rev. 1.03                                         //
//-----------------------------------------------------------------//
// Notes       | class functions exported from Ccambuf library     //
//             |                                                   //
//             |                                                   //
//-----------------------------------------------------------------//
// (c) 2010 - 2012 PCO AG                                          //
// Donaupark 11 D-93309  Kelheim / Germany                         //
// Phone: +49 (0)9441 / 2005-0   Fax: +49 (0)9441 / 2005-20        //
// Email: info@pco.de                                              //
//-----------------------------------------------------------------//


#ifndef Ccambuf_h
#define Ccambuf_h


#define OUT_BW     0x00
#define OUT_BGR    0x01
#define OUT_BGR0   0x02
#define OUT_PSEUDO 0x03

#define IN_BW     0x00 //input buffer is from BW-Camera
#define IN_COLOR  0x10 //input buffer is from COLOR-Camera

#define MASK_RGB  0x20
#define IN_RGB    0x20 //input buffer is from RGB-Camera
#define IN_RGB0   0x21 //input buffer is from RGB0-Camera
#define IN_BGR    0x22 //input buffer is from BGR-Camera
#define IN_BGR0   0x23 //input buffer is from BGR0-Camera

#define STATUS_INCONVERT 0x01

class Cambuf;


class CCambuf
{
//variables
public:
  int     status;

public:
  CCambuf();
  ~CCambuf();

  int Allocate(int width, int height,int bitpix,int align,int color_in);
  int Allocate(int width, int height,int bitpix,int align);
  int Allocate(int width, int height,int bitpix);
  int Allocate(int size);
  int Allocate();
  int FreeBuffer();

  int Get_Size();
  int Get_actwidth();
  int Get_actheight();
  int Get_actbitpix();
  int Get_actalign();
  void* Get_actadr();

  int SetCalculationRectangle(int firstline,int lastline,int firstrow,int lastrow);
  void GetMinMax(int *min,int *max);
  void GetMinMaxPos(int *min,int *min_pos_x,int *min_pos_y,int *max,int *max_pos_x,int *max_pos_y);

  int CreateHistogramTable();
  int CreateHistogramTable(int *min,int *max,double *mean,double *sigma);
  int CreateHistogramTable(DWORD *histtab,int size,int *min,int *max,double *mean,double *sigma);
  int CreateHistogramTables();

  void Clearbuffer();

  void Set_output_buffer(int mode);
  void Set_output_buffer(int mode,void *bufadr);
  void Set_output_lut(void *lut);

  int GetColorinmode();

  int convert();
  int convert(void *out);
  int convert(void *out,void *lut);
  int convert_bw(void *out,void *lut);
  int convert_col(void *out,void *lut);

  void copy8to24(unsigned char *b8,unsigned char *out);
  void copy8to32(unsigned char *b8,unsigned char *out);


  int subtract(CCambuf *pic);
  int subtract(CCambuf *pic,int offset);

  int reduce(CCambuf *pic,int factor);


protected:
  Cambuf *cambuf;
};

#endif
//-----------------------------------------------------------------//
// Name        | clhs_register.h             | Type: ( ) source    //
//-------------------------------------------|       (*) header    //
// Project     | SC2                         |       ( ) others    //
//-----------------------------------------------------------------//
// Platform    | WINDOWS                                           //
//-----------------------------------------------------------------//
// Environment | Microsoft Visual Studio                           //
//             |                                                   //
//-----------------------------------------------------------------//
// Purpose     | CLHS Header                                       //
//-----------------------------------------------------------------//
// Author      | MBL, PCO AG                                       //
//-----------------------------------------------------------------//
// Revision    | rev. 0.01 rel. 0.00                               //
//-----------------------------------------------------------------//
// Notes       |                                                   //
//             |                                                   //
//             |                                                   // 
//-----------------------------------------------------------------//
// (c) 2014 PCO AG  * Donaupark 11 *                               //
// D-93309      Kelheim / Germany * Phone: +49 (0)9441 / 2005-0 *  //
// Fax: +49 (0)9441 / 2005-20 * Email: info@pco.de                 //
//-----------------------------------------------------------------//


//-----------------------------------------------------------------//
// Revision History:                                               //
//-----------------------------------------------------------------//
// Rev.:     | Date:      | Changed:                               //
// --------- | ---------- | ---------------------------------------//
//  0.01     | 16.10.2014 |  new file                              //
//-----------------------------------------------------------------//
//  0.0x     | xx.xx.200x |                                        //
//-----------------------------------------------------------------//
#ifndef CLHS_REGISTER_H
#define CLHS_REGISTER_H

#pragma pack(push)
#pragma pack(1)

//Bootstrap register addresse
typedef struct _CLHS_GENCP_REG32 {
  DWORD adr;
  DWORD size;
}CLHS_GENCP_REG32;

typedef struct _CLHS_GENCP_REG {
  uint64_t adr;
  uint32_t size;
}CLHS_GENCP_REG;


#pragma pack(pop)

#define ABRM_GENCP_VERSION(reg)              reg.adr=0x00000,reg.size=4;
#define ABRM_VENDOR(reg)                     reg.adr=0x00004,reg.size=64;
#define ABRM_MODEL(reg)                      reg.adr=0x00044,reg.size=64;
#define ABRM_FAMILY(reg)                     reg.adr=0x00084,reg.size=64;
#define ABRM_DEVICE_VERSION(reg)             reg.adr=0x000C4,reg.size=64;
#define ABRM_MANUFACTOR(reg)                 reg.adr=0x00104,reg.size=64;
#define ABRM_SERIAL(reg)                     reg.adr=0x00144,reg.size=64;
#define ABRM_USER_NAME(reg)                  reg.adr=0x00184,reg.size=64;
#define ABRM_DEVICE_CAP(reg)                 reg.adr=0x001C4,reg.size=8;
#define ABRM_MAX_RESPONSE(reg)               reg.adr=0x001CC,reg.size=4;
#define ABRM_MANIFEST_OFFSET(reg)            reg.adr=0x001D0,reg.size=8;
#define ABRM_SBMR_OFFSET(reg)                reg.adr=0x001D8,reg.size=8;
#define ABRM_DEVICE_CONFIG(reg)              reg.adr=0x001E0,reg.size=8;
#define ABRM_HEARTBEAT_TIMEOUT(reg)          reg.adr=0x001E8,reg.size=4;
#define ABRM_MESSAGE_CHANNEL_ID(reg)         reg.adr=0x001EC,reg.size=4;
#define ABRM_TIMESTAMP(reg)                  reg.adr=0x001F0,reg.size=8;
#define ABRM_TIMESTAMP_LATCH(reg)            reg.adr=0x001F8,reg.size=4;
#define ABRM_TIMESTAMP_INC(reg)              reg.adr=0x001FC,reg.size=8;
#define ABRM_ACCESS_PRIVILEG(reg)            reg.adr=0x00204,reg.size=4;


#define ABRM_TEST_0(reg)                     reg.adr=0x08000,reg.size=4;
#define ABRM_TEST_1(reg)                     reg.adr=0x08004,reg.size=4;
#define ABRM_TEST_2(reg)                     reg.adr=0x08008,reg.size=4;
#define ABRM_TEST_3(reg)                     reg.adr=0x0800C,reg.size=4;
#define ABRM_TEST_4(reg)                     reg.adr=0x08010,reg.size=4;


//the offset of 0x10000 is only valid for pco camera
//in general the offset should be read from ABRM_SBMR_OFFSET register
//see below
#define SBRM_LLDEVICE_ID(reg)                reg.adr=0x10000,reg.size=4;
#define SBRM_PORT_ID(reg)                    reg.adr=0x10004,reg.size=4;
#define SBRM_AVAIL_PORT(reg)                 reg.adr=0x10008,reg.size=4;
#define SBRM_DEVICE_CLASS(reg)               reg.adr=0x1000C,reg.size=4;
#define SBRM_ACTUAL_DEVICE_CONFIG(reg)       reg.adr=0x10010,reg.size=4;
#define SBRM_NEXT_DEVICE_CONFIG(reg)         reg.adr=0x10014,reg.size=4;
#define SBRM_NUM_DEVICE_CONFIG(reg)          reg.adr=0x10018,reg.size=4;
#define SBRM_DEVICE_CONFIG_LIST(reg)         reg.adr=0x1001C,reg.size=256;  //8*32
#define SBRM_DEVICE_CONFIG_ENTRY0(reg)       reg.adr=0x1001C,reg.size=8;  //first
#define SBRM_DEVICE_CONFIG_ENTRY1(reg)       reg.adr=0x10024,reg.size=8;  //second
#define SBRM_DEVICE_CONFIG_ENTRY2(reg)       reg.adr=0x1002C,reg.size=8;  //third
#define SBRM_ACTIVE_LINK_GPIO(reg)           reg.adr=0x1011C,reg.size=4;
#define SBRM_GPIO_INPUT_CAP(reg)             reg.adr=0x10120,reg.size=4;
#define SBRM_GPIO_OUTPUT_CAP(reg)            reg.adr=0x10124,reg.size=4;
#define SBRM_ACTUAL_LINK_SPEED(reg)          reg.adr=0x10128,reg.size=4;
#define SBRM_SUPPORTED_LINK_SPEED_LIST(reg)  reg.adr=0x1012C,reg.size=64;  //4*16
#define SBRM_NUM_SUPPORTED_LINK_SPEEDS(reg)  reg.adr=0x1016C,reg.size=4;
#define SBRM_NEXT_LINK_SPEED(reg)            reg.adr=0x10170,reg.size=4;
#define SBRM_ACTIVATE_HOTPLUG(reg)           reg.adr=0x10174,reg.size=4;
#define SBRM_SENSOR_WIDTH(reg)               reg.adr=0x10178,reg.size=4;
#define SBRM_SENSOR_HEIGHT(reg)              reg.adr=0x1017C,reg.size=4;
#define SBRM_BINNING_HORIZONTAL(reg)         reg.adr=0x10180,reg.size=4;
#define SBRM_BINNING_VERTICAL(reg)           reg.adr=0x10184,reg.size=4;
#define SBRM_DECIMATION_HORIZONTAL(reg)      reg.adr=0x10188,reg.size=4;
#define SBRM_DECIMATION_VERTICAL(reg)        reg.adr=0x1018C,reg.size=4;
#define SBRM_WIDTH_MAX(reg)                  reg.adr=0x10190,reg.size=4;
#define SBRM_HEIGHT_MAX(reg)                 reg.adr=0x10194,reg.size=4;
#define SBRM_SINGLE_ROI(reg)                 reg.adr=0x10198,reg.size=8;
#define SBRM_PIXEL_TYPE(reg)                 reg.adr=0x101A0,reg.size=4;
#define SBRM_BIT_DEPTH(reg)                  reg.adr=0x101A4,reg.size=4;
#define SBRM_PORT_ROI(reg)                   reg.adr=0x101A8,reg.size=64;  //8*8
#define SBRM_DECIMATION_FACTOR(reg)          reg.adr=0x101E8,reg.size=4;
#define SBRM_ELECTRIC_CABLE_SWAP(reg)        reg.adr=0x101EC,reg.size=4;
#define SBRM_ROW_OVERLAP(reg)                reg.adr=0x101F0,reg.size=4;
#define SBRM_PULSE_MODE_CAP(reg)             reg.adr=0x101F4,reg.size=4;


//defines with offset from ABRM_SBMR_OFFSET register

#define SBRMO_LLDEVICE_ID(reg,off)                reg.adr=0x00000+off,reg.size=4;
#define SBRMO_PORT_ID(reg,off)                    reg.adr=0x00004+off,reg.size=4;
#define SBRMO_AVAIL_PORT(reg,off)                 reg.adr=0x00008+off,reg.size=4;
#define SBRMO_DEVICE_CLASS(reg,off)               reg.adr=0x0000C+off,reg.size=4;
#define SBRMO_ACTUAL_DEVICE_CONFIG(reg,off)       reg.adr=0x00010+off,reg.size=4;
#define SBRMO_NEXT_DEVICE_CONFIG(reg,off)         reg.adr=0x00014+off,reg.size=4;
#define SBRMO_NUM_DEVICE_CONFIG(reg,off)          reg.adr=0x00018+off,reg.size=4;
#define SBRMO_DEVICE_CONFIG_LIST(reg,off)         reg.adr=0x0001C+off,reg.size=256;  //8*32
#define SBRMO_DEVICE_CONFIG_ENTRY0(reg,off)       reg.adr=0x0001C+off,reg.size=8;  //first
#define SBRMO_DEVICE_CONFIG_ENTRY1(reg,off)       reg.adr=0x00024+off,reg.size=8;  //second
#define SBRMO_DEVICE_CONFIG_ENTRY2(reg,off)       reg.adr=0x0002C+off,reg.size=8;  //third
#define SBRMO_ACTIVE_LINK_GPIO(reg,off)           reg.adr=0x0011C+off,reg.size=4;
#define SBRMO_GPIO_INPUT_CAP(reg,off)             reg.adr=0x00120+off,reg.size=4;
#define SBRMO_GPIO_OUTPUT_CAP(reg,off)            reg.adr=0x00124+off,reg.size=4;
#define SBRMO_ACTUAL_LINK_SPEED(reg,off)          reg.adr=0x00128+off,reg.size=4;
#define SBRMO_SUPPORTED_LINK_SPEED_LIST(reg,off)  reg.adr=0x0012C+off,reg.size=64;  //4*16
#define SBRMO_NUM_SUPPORTED_LINK_SPEEDS(reg,off)  reg.adr=0x0016C+off,reg.size=4;
#define SBRMO_NEXT_LINK_SPEED(reg,off)            reg.adr=0x00170+off,reg.size=4;
#define SBRMO_ACTIVATE_HOTPLUG(reg,off)           reg.adr=0x00174+off,reg.size=4;
#define SBRMO_SENSOR_WIDTH(reg,off)               reg.adr=0x00178+off,reg.size=4;
#define SBRMO_SENSOR_HEIGHT(reg,off)              reg.adr=0x0017C+off,reg.size=4;
#define SBRMO_BINNING_HORIZONTAL(reg,off)         reg.adr=0x00180+off,reg.size=4;
#define SBRMO_BINNING_VERTICAL(reg,off)           reg.adr=0x00184+off,reg.size=4;
#define SBRMO_DECIMATION_HORIZONTAL(reg,off)      reg.adr=0x00188+off,reg.size=4;
#define SBRMO_DECIMATION_VERTICAL(reg,off)        reg.adr=0x0018C+off,reg.size=4;
#define SBRMO_WIDTH_MAX(reg,off)                  reg.adr=0x00190+off,reg.size=4;
#define SBRMO_HEIGHT_MAX(reg,off)                 reg.adr=0x00194+off,reg.size=4;
#define SBRMO_SINGLE_ROI(reg,off)                 reg.adr=0x00198+off,reg.size=8;
#define SBRMO_PIXEL_TYPE(reg,off)                 reg.adr=0x001A0+off,reg.size=4;
#define SBRMO_BIT_DEPTH(reg,off)                  reg.adr=0x001A4+off,reg.size=4;
#define SBRMO_PORT_ROI(reg,off)                   reg.adr=0x001A8+off,reg.size=64;  //8*8
#define SBRMO_DECIMATION_FACTOR(reg,off)          reg.adr=0x001E8+off,reg.size=4;
#define SBRMO_ELECTRIC_CABLE_SWAP(reg,off)        reg.adr=0x001EC+off,reg.size=4;
#define SBRMO_ROW_OVERLAP(reg,off)                reg.adr=0x001F0+off,reg.size=4;
#define SBRMO_PULSE_MODE_CAP(reg,off)             reg.adr=0x001F4+off,reg.size=4;


#define MANIFEST_ENTRY_COUNT_OFF(reg)             reg.adr=0x00000,reg.size=8;

#define MANIFEST_ENTRY0_FILE_VERS_OFF(reg)        reg.adr=0x00008,reg.size=4;
#define MANIFEST_ENTRY0_FILE_TYPE_OFF(reg)        reg.adr=0x0000C,reg.size=4;
#define MANIFEST_ENTRY0_FILE_ADDRESS_OFF(reg)     reg.adr=0x00010,reg.size=8;
#define MANIFEST_ENTRY0_FILE_SIZE_OFF(reg)        reg.adr=0x00018,reg.size=8;
#define MANIFEST_ENTRY0_SHA1HASH_OFF(reg)         reg.adr=0x00020,reg.size=20;
#define MANIFEST_ENTRY0_RESERVED_OFF(reg)         reg.adr=0x00034,reg.size=20;

#define MANIFEST_ENTRY1_FILE_VERS_OFF(reg)        reg.adr=0x00048,reg.size=4;
#define MANIFEST_ENTRY1_FILE_TYPE_OFF(reg)        reg.adr=0x0004C,reg.size=4;
#define MANIFEST_ENTRY1_FILE_ADDRESS_OFF(reg)     reg.adr=0x00050,reg.size=8;
#define MANIFEST_ENTRY1_FILE_SIZE_OFF(reg)        reg.adr=0x00058,reg.size=8;
#define MANIFEST_ENTRY1_SHA1HASH_OFF(reg)         reg.adr=0x00060,reg.size=20;
#define MANIFEST_ENTRY1_RESERVED_OFF(reg)         reg.adr=0x00074,reg.size=20;

//#define MANIFEST_ENTRY2_FILE_VERS_OFF        reg.adr=0x00088,reg.size=20;


#define PCO_WIDTH(reg)                            reg.adr=0x00030000,reg.size=4;
#define PCO_HEIGHT(reg)                           reg.adr=0x00030004,reg.size=4;
#define PCO_PIXEL_FORMAT(reg)                     reg.adr=0x00030008,reg.size=4;
/*kann ich leider so nicht hernehmen da unterschiedlich register addressen in flow und edge 
#define PCO_ACQUISITION_MODE(reg)                 reg.adr=0x00030010,reg.size=4;
#define PCO_ACQUISITION_START(reg)                reg.adr=0x00030014,reg.size=4;
#define PCO_ACQUISITION_STOP(reg)                 reg.adr=0x00030018,reg.size=4;
#define PCO_WIDTH_MAX(reg)                        reg.adr=0x0003001C,reg.size=4;
#define PCO_HEIGHT_MAX(reg)                       reg.adr=0x00030020,reg.size=4;
#define PCO_OFFSET_X(reg)                         reg.adr=0x00030024,reg.size=4;
#define PCO_OFFSET_Y(reg)                         reg.adr=0x00030028,reg.size=4;
#define PCO_LINE_ID(reg)                          reg.adr=0x0003002C,reg.size=4;

#define PCO_TESTIMAGE(reg)                        reg.adr=0x00040124,reg.size=4;
*/
#define PCO_CONTROL_COMMAND(reg)                  reg.adr=0x00040000;



typedef struct _CLHS_CONFIGREG {
  DWORD AvailPorts;
  DWORD NumConfig;
  DWORD ActualConfig;
  DWORD NextConfig;
  uint64_t config[32];
}CLHS_CONFIGREG;


typedef struct _CLHS_PORT_BOOTREG {
  char Vendor[64];
  char Model[64];
  char Serial[64];
  CLHS_CONFIGREG master;
}CLHS_PORT_BOOTREG;

#define PT_MONO8    0x01080001
#define PT_MONO8S   0x01080002
#define PT_MONO10   0x01100003
#define PT_MONO12   0x01100005
#define PT_MONO16   0x01100007
#define PT_MONO10P  0x010A0046
#define PT_MONO12P  0x010C0047

#define PT_BAYERGB8     0x0108000A
#define PT_BAYERGB10P   0x010A0054

#endif


//-----------------------------------------------------------------//
// Name        | cnv_s.h                     | Type: ( ) source    //
//-------------------------------------------|       (*) header    //
// Project     | PCO                         |       ( ) others    //
//-----------------------------------------------------------------//
// Platform    | PC                                                //
//-----------------------------------------------------------------//
// Environment | Visual 'C++'                                      //
//-----------------------------------------------------------------//
// Purpose     | PCO - Convert DLL struct definitions              //
//-----------------------------------------------------------------//
// Author      | MBL, PCO AG                                       //
//-----------------------------------------------------------------//
// Revision    |  rev. 1.15 rel. 1.15                              //
//-----------------------------------------------------------------//
// Notes       |                                                   //
//-----------------------------------------------------------------//
// (c) 2002 PCO AG * Donaupark 11 *                                //
// D-93309      Kelheim / Germany * Phone: +49 (0)9441 / 2005-0 *  //
// Fax: +49 (0)9441 / 2005-20 * Email: info@pco.de                 //
//-----------------------------------------------------------------//

//-----------------------------------------------------------------//
// Revision History:                                               //
//-----------------------------------------------------------------//
// Rev.:     | Date:      | Changed:                               //
// --------- | ---------- | ---------------------------------------//
//  1.10     | 03.07.2003 |  gamma, alignement added, FRE          //
//-----------------------------------------------------------------//
//  1.13     | 16.03.2005 |  PCO_CNV_COL_SET added, FRE            //
//-----------------------------------------------------------------//
//  1.15     | 23.10.2007 |  PCO_CNV_COL_SET removed, FRE          //
//           |            |  Adapted all structures due to merging //
//           |            |  the data sets of the dialoges         //
//-----------------------------------------------------------------//
//  0.0      |   .  .2003 |                                        //
//           |            |                                        //
//-----------------------------------------------------------------//

// @ver1.000

// defines for Lut's ...
// local functions

//--------------------

#ifndef CNV_S_H
#define CNV_S_H

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#define MAX_LUT           60           // max. number of luts supported
#define MAX_OUTSIZE      256           // max. output value for 8bit
#define MAX_BITPIX        16           // max. input value supported
#define MAX_TYPES          2

#define MODE_FLIP_B       0x0001
#define MODE_MIRROR_B     0x0002
#define MODE_OUT32_B      0x0010
#define MODE_PSEUDO_B     0x0020


// eingef�gt: 18.01.2007 - RFR
struct sRGB_color_correction_coefficients
{
	double da11, da12, da13;
	double da21, da22, da23;
	double da31, da32, da33;
};

typedef struct sRGB_color_correction_coefficients SRGBCOLCORRCOEFF;

struct bw_lut
{
  unsigned short wSize;               // size of bw_lut array
  int       min;
  int       max;
  int       typ;
  int       mid;
  int       min_out;
  int       max_out;
  int       size;
  void      *ptr;
  int       bitpix; // eingef�gt: 30.06.2003 - FRE
  int       align; // align 0: rechtsb�ndig(wie SC, PCCam), 1: linksb�ndig(SC2); eingef�gt: 30.06.2003 - FRE
  double    dgamma; // eingef�gt: 30.06.2003 - FRE
  unsigned long dwFlags;                   // Flags: Bit0(1)->align upper, Bit1(2)->Set parameter active
                                       //        Bit2(4)->do sRGB,     Bit3(8)->Inverted table
                                       //        Bit4(16)->16bit out
};

typedef struct bw_lut BWLUT;


struct color_lut
{
  unsigned short wSize;                // size of color_lut array
  BWLUT     red;
  BWLUT     green;
  BWLUT     blue;
  double    dColorSaturation;          // Color saturation
  double    dRedGainColTempCorr;       // Contrast gain for color temp. correction red (camera spec. value)
  double    dGreenGainColTempCorr;     // Contrast gain for color temp. correction green (camera spec. value)
  double    dBlueGainColTempCorr;      // Contrast gain for color temp. correction blue (camera spec. value)
  unsigned short wDarkOffset;          // Offset of the image sensor, while shutter is closed (typically 30..100)
  SRGBCOLCORRCOEFF strColorCoeff;      // Color coefficients for sRGB color space
  unsigned long dwFlags;               // Flags: Bit0(1)->align upper, Bit1(2)->Set parameter active
                                       //        Bit2(4)->do sRGB,     Bit3(8)->Inverted table
                                       //        Bit4(16)->16bit out
};

struct pseudo_lut
{
  unsigned short wSize;                // size of pseudo_lut array
  BWLUT bw;
  int psize;
  unsigned char *red_ptr;
  unsigned char *green_ptr;
  unsigned char *blue_ptr;
  unsigned long dwFlags;               // Flags: Bit0(1)->align upper, Bit1(2)->Set parameter active
};

typedef struct color_lut COLORLUT;
typedef struct pseudo_lut PSEUDOLUT;

// PCO_CNV_COL_SET Flags
#define PCO_CNV_SET_ALIGNUPPER     0x0001
#define PCO_CNV_SET_SETISACTIVE    0x0002
#define PCO_CNV_SET_DOsRGB         0x0004
#define PCO_CNV_SET_INVERS         0x0008
#define PCO_CNV_SET_CREATEOUT16    0x0010

// PCO_LUT_DLG_INFO Flags
#define PCO_LUT_DLG_INFO_OPENCBSDLG 1  // Opens contrast-brightness-saturation dialog

typedef struct
{
  unsigned short wSize;                // size of this struct
  unsigned short wId;                  // Id of the calling class (use e.g. the camera class)
  unsigned long  dwFlags;              // Bit0: Open CollutCommon
}PCO_LUT_DLG_INFO;                     // This structure can be used to open a new sheet of a already open
                                       // dialog instead of opening as a complete new dialog.
                                       // To add only a sheet you have to set the wId before calling the
                                       // open function.



#endif                                 /* CNV_S_H */
//-----------------------------------------------------------------//
// Name        | cnvbw.h                     | Type: ( ) source    //
//-------------------------------------------|       (*) header    //
// Project     | PCO                         |       ( ) others    //
//-----------------------------------------------------------------//
// Platform    | PC                                                //
//-----------------------------------------------------------------//
// Environment | Visual 'C++'                                      //
//-----------------------------------------------------------------//
// Purpose     | PCO - Convert DLL function call definitions       //
//-----------------------------------------------------------------//
// Author      | MBL, PCO AG                                       //
//-----------------------------------------------------------------//
// Revision    |  rev. 1.15 rel. 1.15                              //
//-----------------------------------------------------------------//
// Notes       |                                                   //
//-----------------------------------------------------------------//
// (c) 2003 PCO AG * Donaupark 11 *                                //
// D-93309      Kelheim / Germany * Phone: +49 (0)9441 / 2005-0 *  //
// Fax: +49 (0)9441 / 2005-20 * Email: info@pco.de                 //
//-----------------------------------------------------------------//


//-----------------------------------------------------------------//
// Revision History:                                               //
//-----------------------------------------------------------------//
// Rev.:     | Date:      | Changed:                               //
// --------- | ---------- | ---------------------------------------//
//  1.10     | 03.07.2003 |  gamma, alignement added, FRE          //
//-----------------------------------------------------------------//
//  1.11     | 09.07.2004 |  RGGB sensitive, FRE                   //
//-----------------------------------------------------------------//
//  1.14     | 12.05.2006 |  added _to24, FRE                      //
//-----------------------------------------------------------------//
//  1.15     | 23.10.2007 |  PCO_CNV_COL_SET removed, FRE          //
//           |            |  Adapted all structures due to merging //
//           |            |  the data sets of the dialoges         //
//-----------------------------------------------------------------//
//  0.0      |   .  .2003 |                                        //
//           |            |                                        //
//-----------------------------------------------------------------//
#ifndef CNVBW_H
#define CNVBW_H


void convert_set_colset(BWLUT *lut, double dHell, double dKontr, double dCol, double dGamma, double dDarkOffset);
void convert_set(BWLUT *lut);

BWLUT *create_bwlut(int bitpix,int min_out,int max_out, int ialign);
int del_bwlut(BWLUT *lut);

COLORLUT *create_colorlut(int bitpix,int min_out,int max_out, int ialign);
int del_colorlut(COLORLUT *clut);

PSEUDOLUT *create_pseudolut(int bitpix,int min_out,int max_out, int ialign);
int del_pseudolut(PSEUDOLUT *plut);


void convert(int width,int height,unsigned short *b12,unsigned char *b8,BWLUT *bwlut);
void flip_convert(int width,int height,unsigned short *b12,unsigned char *b8,BWLUT *bwlut);
void mirror_convert(int width,int height,unsigned short *b12,unsigned char *b8,BWLUT *bwlut);
void flip_mirror_convert(int width,int height,unsigned short *b12,unsigned char *b8,BWLUT *bwlut);

void convert_to24(int width,int height,unsigned short *b12,unsigned char *b8,BWLUT *bwlut);
void flip_convert_to24(int width,int height,unsigned short *b12,unsigned char *b8,BWLUT *bwlut);
void mirror_convert_to24(int width,int height,unsigned short *b12,unsigned char *b8,BWLUT *bwlut);
void flip_mirror_convert_to24(int width,int height,unsigned short *b12,unsigned char *b8,BWLUT *bwlut);

void convert_to32(int width,int height,unsigned short *b12,void *b8,BWLUT *bwlut);
void flip_convert_to32(int width,int height,unsigned short *b12,void *b8,BWLUT *bwlut);
void mirror_convert_to32(int width,int height,unsigned short *b12,void *b8,BWLUT *bwlut);
void flip_mirror_convert_to32(int width,int height,unsigned short *b12,void *b8,BWLUT *bwlut);



#endif /* CNVBW_H */
#ifndef EDGE_CORRECTIONMODE_H
#define EDGE_CORRECTIONMODE_H


//---------command code

#define GET_CORRECTION_MODE    0x2A11
#define SET_CORRECTION_MODE    0x2B11


//-------- telegram structure

typedef struct
{
  WORD        wCode;                   // telegram code 
  WORD        wSize;                   // telegram length
  WORD        wMode;                   // see defines
  WORD        wOffs;                   
  WORD        wRsrvd1;
  WORD        wRsrvd2;
  BYTE        bCks;                    // checksum byte
} SC2_Set_Correction_Mode;

#define SC2_Set_Correction_Mode_Response SC2_Set_Correction_Mode
#define SC2_Get_Correction_Mode_Response SC2_Set_Correction_Mode

//-------- correction mode settings

#define CORRMODE_COMPLETELY_OFF          0x0000
#define CORRMODE_DSNU_CORRECTION         0x0001
#define CORRMODE_LINEARIZATION           0x0004


#endif // ifndef EDGE_CORRECTIONMODE_H

// ------------------------------< end of file >--------------------------- //

//-----------------------------------------------------------------//
// Name        | Cpco_com.h                  | Type: ( ) source    //
//-------------------------------------------|       (*) header    //
// Project     | pco.camera                  |       ( ) others    //
//-----------------------------------------------------------------//
// Platform    | LINUX                                             //
//-----------------------------------------------------------------//
// Environment | gcc                                               //
//             |                                                   //
//-----------------------------------------------------------------//
// Purpose     | pco.camera - Communication                        //
//-----------------------------------------------------------------//
// Author      | MBL, PCO AG                                       //
//-----------------------------------------------------------------//
// Revision    | rev. 1.04                                         //
//-----------------------------------------------------------------//
// Notes       | Common functions                                  //
//             |                                                   //
//             |                                                   //
//-----------------------------------------------------------------//
// (c) 2010 - 2015 PCO AG                                          //
// Donaupark 11 D-93309  Kelheim / Germany                         //
// Phone: +49 (0)9441 / 2005-0   Fax: +49 (0)9441 / 2005-20        //
// Email: info@pco.de                                              //
//-----------------------------------------------------------------//


//-----------------------------------------------------------------//
// Revision History:                                               //
//  see Cpco_com.cpp                                               //
//-----------------------------------------------------------------//

#ifndef CPCO_COM_H
#define CPCO_COM_H

// GNU specific __attribute__((unused)) define
#ifdef __GNUC__
#define ATTRIBUTE_UNUSED __attribute__((unused))
#else
#define ATTRIBUTE_UNUSED
#endif

#include "pco_includes.h"
#include "VersionNo.h"

#if !defined (MAX_PATH)
#define MAX_PATH 1024
#endif


/*! \page page1 Introduction
  This manual provides an detailed description of all functions of the PCO Camera Linux API.
  The API is a class interface and provides the functionality to write own Applications in a Linux environment.
  Any C++ compiler can be used for development. 
  The intention was to provide a simple interface, which can be used with every PCO camera of
  the pco.camera series independent from the used interface.
 
  \section sec General
  The API consist of two classes a communication class which is used to control the camera settings
  and a grabber class which is used to transfer single or multiple images from the camera to the PC.
  Because communication with the camera and image transfer depends on the used hardware interface,
  interface specific classes exist.
  For controlling the camera settings a common base class exists. The interface specific classes
  are subclasses derived from the base class.  
  For image transfers only interface specific classes exist, but main functions use equal function declarations. 
  \latexonly \newpage \endlatexonly
*/


//nochmalige unterteilung funktioniert so
//  This page contains the subsections \ref subsection1 and \ref subsection2.
//  For more info see page \ref page2.
//  \subsection subsection1 The first subsection
//  Text.
//  \subsection subsection2 The second subsection
//  More text.


///
/// \brief Base interface class
///
/// Derived from this class are all interface specific classes. It includes some common functions and defines the mandatory functions that each subclass has to implement.
///
///\nosubgrouping



class CPco_com {
public:
    WORD   num_lut;
    SC2_LUT_DESC cam_lut[10];

protected:
    //common
    CPco_Log *clog;
    PCO_HANDLE hdriver;
    DWORD  initmode;
    DWORD  boardnr;
    DWORD  camerarev;
    bool internal_open;
    DWORD connected;

    PCO_SC2_TIMEOUTS tab_timeout;
    SC2_Camera_Description_Response description;

    //functions
public:
    CPco_com();
    virtual ~CPco_com(){}

    ///
    /// \brief Opens a connection to a pco.camera
    /// \anchor Open_Cam
    /// \param num Number of the camera starting with zero.
    /// \return Error code or 0 on success
    ///
    virtual DWORD Open_Cam(DWORD num)=0;

    ///
    /// \brief Opens a connection to a pco.camera
    /// \anchor Open_Cam_Ext
    /// \param num Number of the camera starting with zero.
    /// \param strOpen Unused.
    /// \return Error code or 0 on success
    ///
    virtual DWORD Open_Cam_Ext(DWORD num,SC2_OpenStruct *strOpen)=0;

    ///
    /// \brief Closes a connection with a pco.camera
    /// \anchor Close_Cam
    /// Not all classes derived from this must implement a close function.
    /// \return Error code or 0 on success
    ///
    virtual DWORD Close_Cam(){return PCO_NOERROR;}

    ///
    /// \brief The main function to communicate with the camera via PCO telegrams
    /// \anchor Control_Command
    /// See sc2_telegram.h for a list of telegrams and sc2_command.h for a list of possible commands
    ///
    /// Checksum calculation is done in this function, no need to pre-calculate it.
    /// \param buf_in Pointer to the buffer where the telegram is stored
    /// \param size_in Pointer to a DWORD that holds the input size of the buffer
    /// \param buf_out Pointer to the buffer where the response gets stored
    /// \param size_out Pointer to a DWORD that holds the size of the buffer. This is updated with the returned size.
    /// \return Error code or 0 on success
    ///
    virtual DWORD Control_Command(void *buf_in,DWORD size_in,void *buf_out,DWORD size_out)=0;

    ///
    /// \brief Sets the logging behaviour for the communication class.
    /// \n
    /// If this function is not called no logging is performed.
    /// Logging might be useful to follow the program flow of the application.
    /// \param Log Pointer to a CPco_Log logging class object
    /// \return
    ///
    void SetLog(CPco_Log *Log);

    /// \cond

protected:
    ///
    /// \brief Writes a log entry
    /// \anchor writelog
    /// \param level Type of the entry, e.g. Error, Status, Message, ...
    /// \param hdriver The source of the error
    /// \param message The actual log message as printf formatted string
    /// \return Error code or 0 on success
    ///
    void writelog(DWORD level,PCO_HANDLE hdriver,const char *message,...);

    ///
    /// \brief Scans the connected camera and gets basic informations
    /// \anchor scan_camera
    /// \return Error code or 0 on success
    ///
    virtual DWORD scan_camera()=0;

    ///
    /// \brief Builds the checksum for Control_Command() telegrams
    /// \anchor build_checksum
    /// \param buf Pointer to buffer that contains the telegram
    /// \param size Pointer to size of the buffer
    /// \return Error code or 0 on success
    ///
    DWORD build_checksum(unsigned char *buf,int *size);

    ///
    /// \brief Verifies the checksum for a telegram
    /// \anchor test_checksum
    /// \param buf Pointer to buffer that contains the telegram
    /// \param size Pointer to size of the buffer
    /// \return Error code or 0 on success
    ///
    DWORD test_checksum(unsigned char *buf,int *size);

    ///
    /// \brief Gets the camera descriptor and caches it
    /// \anchor get_description
    /// \return Error code or 0 on success
    ///
    DWORD get_description();

    ///
    /// \brief Gets camera main processor and main FPGA firmware versions and writes them to the logfile
    /// \anchor get_firmwarerev
    /// \return Error code or 0 on success
    ///
    DWORD get_firmwarerev();

    ///
    /// \brief Gets installed LUTs and writes them to the logfile
    /// \anchor get_lut_info
    /// \return Error code or 0 on success
    ///
    DWORD get_lut_info();


    /// \endcond

public:

#include "Cpco_com_func.h"
#include "Cpco_com_func_2.h"


    /// @name Class Control Functions
    ///
    /// These functions are used to control some internal variables of the class.
    ///

    ///
    /// \brief Gets the current timeouts for images and telegrams
    /// \anchor gettimeouts
    /// \param strTimeouts Pointer to a PCO_SC2_TIMEOUTS structure
    /// \return
    ///
    void gettimeouts(PCO_SC2_TIMEOUTS *strTimeouts);

    ///
    /// \brief Sets the timeouts
    /// \anchor Set_Timeouts
    /// \param timetable Pointer to an DWORD array. First parameter is the command timeout, second the image timeout, third the transfer timeout.
    /// \param length Length of the array in bytes, a maximum of 12 bytes are used.
    /// \return 
    ///
    void Set_Timeouts(void *timetable,DWORD length);

    ///
    /// \brief GetConnectionStatus
    /// \anchor GetConnectionStatus
    /// \return Connectionstatus
    /// \retval 1 connected
    /// \retval 0 not connected
    int GetConnectionStatus();

    ///
    /// \brief Sets the connection status
    /// \anchor SetConnectionStatus
    /// \param status 
    /// \return 
    ///
    void SetConnectionStatus(DWORD status);

    ///
    /// \brief Common sleep function for Linux/Windows
    /// \anchor Sleep_ms
    /// \param time_ms Time to sleep in ms
    /// \return 
    ///
    void Sleep_ms(DWORD time_ms);

};

#endif





//-----------------------------------------------------------------//
// Name        | Cpco_com_clhs.h             | Type: ( ) source    //
//-------------------------------------------|       (*) header    //
// Project     | pco.camera                  |       ( ) others    //
//-----------------------------------------------------------------//
// Platform    | Linux                                             //
//-----------------------------------------------------------------//
// Environment |                                                   //
//             |                                                   //
//-----------------------------------------------------------------//
// Purpose     | pco.camera - clhs communication                   //
//-----------------------------------------------------------------//
// Author      | MBL, PCO AG                                       //
//-----------------------------------------------------------------//
// Revision    | rev. 0.01 rel. 0.00                               //
//-----------------------------------------------------------------//
// Notes       | Common functions                                  //
//             |                                                   //
//             |                                                   //
//-----------------------------------------------------------------//
// (c) 2016 - 2016 PCO AG                                          //
// Donaupark 11 D-93309  Kelheim / Germany                         //
// Phone: +49 (0)9441 / 2005-0   Fax: +49 (0)9441 / 2005-20        //
// Email: info@pco.de                                              //
//-----------------------------------------------------------------//

//-----------------------------------------------------------------//
// Revision History:                                               //
//  see Cpco_com_clhs.cpp                                          //
//-----------------------------------------------------------------//

#ifndef CPCO_COM_CLHS_H
#define CPCO_COM_CLHS_H

#include "pco_includes.h"
#include "Cpco_com.h"
#include "VersionNo.h"

#include "pco_clhs_cam.h"

#define MAXNUM_DEVICES 8


///
/// \brief The CPco_com_clhs class, extends CPco_com
///
/// This is the communication class to exchange messages (telegrams) with a pco.camera.
///

class CPco_com_clhs : public CPco_com
{

public:

protected:

    ///
    /// \brief Semaphore to lock the Control_Command()
    ///

    sem_t sMutex;
    CPco_clhs_cam* Cclhs_cam;

    //functions
public:
    CPco_com_clhs();
    ~CPco_com_clhs();

    ///
    /// \implements Open_Cam
    ///
    DWORD Open_Cam(DWORD num);

    ///
    /// \implements Open_Cam_Ext
    ///
    DWORD Open_Cam_Ext(DWORD num,SC2_OpenStruct *open);

    ///
    /// \brief Closes a connection to a pco camera.
    /// 
    /// Call this function to end the connection with a camera, e.g. when exiting the program, switching to another camera while the program is running, etc.
    /// \return Error or 0 on success
    ///
    DWORD Close_Cam();

    ///
    /// \brief Returns connection status
    /// \anchor IsOpen
    /// \return 1 if a connection is open, 0 else
    ///
    int  IsOpen();

    ///
    /// \implements Control_Command
    ///
    DWORD Control_Command(void *buf_in,DWORD size_in,void *buf_out,DWORD size_out);


    DWORD scan_camera();

    CPco_clhs_cam* get_C_clhs_cam(void);

protected:

};

#endif
//-----------------------------------------------------------------//
// Name        | Cpco_com_func.h             | Type: ( ) source    //
