/// settings are changed, the user must adapt the ROI, before PCO_ArmCamera() is accessed. The
/// binning setting sets the limits for the ROI. For example, a sensor with 1600x1200 and binning 2x2
/// will result in a maximum ROI of 800x600.
///
/// Some sensors have a ROI stepping. See the camera description and check the parameters
/// wRoiHorStepsDESC and/or wRoiVertStepsDESC. In case stepping is zero ROI setting other than
/// x0=1, x1=max/bin, y0=1, y1=max/bin it not possible (max depends on the selected sensor format;
/// bin depends on the current binning settings).
///
/// For dual ADC mode the horizontal ROI must be symmetrical. For a pco.dimax the horizontal and
/// vertical ROI must be symmetrical. For a pco.edge the vertical ROI must be symmetrical.
///
/// X0, Y0 start at 1. X1, Y1 end with max. sensor size.
///
/// \latexonly \begin{tabular}{| l c r | } \hline x0,y0 & & \\ & ROI & \\ & & x1,y1 \\ \hline \end{tabular} \endlatexonly
///
/// \param RoiX0
/// WORD variable to hold the x value for the upper left corner.
/// \param RoiY0
/// WORD variable to hold the y value for the upper left corner.
/// \param RoiX1
/// WORD variable to hold the x value for the lower right corner.
/// \param RoiY1
/// WORD variable to hold the y value for the lower right corner.
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_SetROI(WORD RoiX0,WORD RoiY0,WORD RoiX1,WORD RoiY1);


///
/// \brief Gets the binning values of the camera.
/// 
/// \param BinHorz Pointer to a WORD variable to hold the horizontal binning value.
/// \param BinVert Pointer to a WORD variable to hold the vertikal binning value.
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_GetBinning(WORD *BinHorz,WORD *BinVert);


///
/// \brief Sets the binning values of the camera.
/// 
/// Set binning. If the binning settings are changed, the user must adapt the ROI, before
/// PCO_ArmCamera() is accessed. The binning setting sets the limits for the ROI. E.g. a sensor with
/// 1600x1200 and binning 2x2 will result in a maximum ROI of 800x600.
/// \param BinHorz WORD variable to hold the horizontal binning value.
/// \param BinVert WORD variable to hold the vertikal binning value.
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_SetBinning(WORD BinHorz,WORD BinVert);


///
/// \brief Get analog-digital-converter (ADC) operation for reading the image sensor data.
///
/// Pixel data can be read out using one ADC (better linearity), or in parallel using two ADCs (faster). This option is
/// only available for some camera models (defined in the camera description). If the user sets 2ADCs he must center and
/// adapt the ROI to symmetrical values, e.g. pco.1600: x1,y1,x2,y2=701,1,900,500 (100,1,200,500 is not possible).
/// \param wADCOperation Pointer to a WORD variable to receive the adc operation mode.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetADCOperation(WORD* wADCOperation);


///
/// \brief Sets the adc operation mode of the camera, if available.
/// 
/// Set analog-digital-converter (ADC) operation for reading the image sensor data. Pixel data can be
/// read out using one ADC (better linearity) or in parallel using two ADCs (faster). This option is
/// only available for some camera models. If the user sets 2ADCs he must center and adapt the ROI
/// to symmetrical values, e.g. pco.1600: x1,y1,x2,y2=701,1,900,500 (100,1,200,500 is not possible).
///
/// The input data has to be filled with the following parameter:
/// - operation to be set:
///   - 0x0001 = 1 ADC or
///   - 0x0002 = 2 ADCs should be used...
/// - the existence of the number of ADCs can be checked with the values defined in the camera description
///
/// \param num
/// WORD variable to hold the adc operation mode.
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_SetADCOperation(WORD num);

///
/// \brief Gets the double image mode of the camera.
///
/// Not applicable to all cameras.
/// \param wDoubleImage Pointer to a WORD variable to receive the double image mode.
/// - 0x0001 = double image mode ON
/// - 0x0000 = double image mode OFF
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetDoubleImageMode(WORD* wDoubleImage);


///
/// \brief Sets the double image mode of the camera.
///
/// Some cameras (defined in the camera description) allow the user to make
/// a double image with two exposures separated by a short interleaving time. A double image is
/// transferred as one frame, that is the two images resulting from the two/double exposures are
/// stitched together as one and are counted as one. Thus the buffer size has to be doubled. The first
/// half of the buffer will be filled with image 'A', the first exposed frame. The second exposure
/// (image 'B') will be transferred to the second half of the buffer.
///
/// Not applicable to all cameras.
/// \param wDoubleImage WORD variable to hold the double image mode.
/// - 0x0001 = double image mode ON
/// - 0x0000 = double image mode OFF
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetDoubleImageMode(WORD wDoubleImage);


///
/// \brief Get the actual noise filter mode. See the camera descriptor for availability of this feature.
///
/// Parameter:
/// - 0x0000 = [OFF]
/// - 0x0001 = [ON]
/// - 0x0101 = [ON + Hot Pixel correction]
///
/// \param wNoiseFilterMode Pointer to a WORD variable to receive the noise filter mode.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetNoiseFilterMode (WORD* wNoiseFilterMode);


///
/// \brief Sets the actual noise filter mode. See the camera descriptor for availability of this feature.
///
/// Parameter:
/// - 0x0000 = [OFF]
/// - 0x0001 = [ON]
/// - 0x0101 = [ON + Hot Pixel correction]
///
/// \param wNoiseFilterMode WORD variable to hold the noise filter mode.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetNoiseFilterMode (WORD wNoiseFilterMode);


///
/// \brief Get image sensor gain setting
///
/// Current conversion factor in electrons/count (the variable must be divided by 100 to get the real value)
///
/// i.e. 0x01B3 (hex) = 435 (decimal) = 4.35 electrons/count conversion factor must be valid as defined in the camera description
/// \param wConvFact Pointer to a WORD variable to receive the conversion factor.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetConversionFactor(WORD* wConvFact);


///
/// \brief Set image sensor gain
///
/// Conversion factor to be set in electrons/count (the variable must be divided by 100 to get the real value)
///
/// i.e. 0x01B3 (hex) = 435 (decimal) = 4.35 electrons/count
///
/// Conversion factor must be valid as defined in the camera description.
/// \param wConvFact WORD to set the conversion factor.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetConversionFactor(WORD wConvFact);


///
/// \brief Gets the IR sensitivity mode of the camera.
///
/// This option is only available for special camera models with image sensors that have improved IR sensitivity.
/// \param wIR Pointer to a WORD variable to receive the IR sensitivity mode.
/// - 0x0000 IR sensitivity OFF
/// - 0x0001 IR sensitivity ON
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetIRSensitivity(WORD* wIR);


///
/// \brief Gets the IR sensitivity mode of the camera.
///
/// Set IR sensitivity for the image sensor. This option is only available for special camera models with image sensors that have improved IR sensitivity.
/// \param wIR WORD variable to set the IR sensitivity mode.
/// - 0x0000 IR sensitivity OFF
/// - 0x0001 IR sensitivity ON
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetIRSensitivity(WORD wIR);


///
/// \brief Get the mode for the offset regulation with reference pixels (see camera manual for further explanations).
///
/// Mode:
/// - 0x0000 = [auto]
/// - 0x0001 = [OFF]
///
/// \param wOffsetRegulation Pointer to a WORD variable to receive the offset mode.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetOffsetMode (WORD* wOffsetRegulation);

///
/// \brief Set the mode for the offset regulation with reference pixels (see the camera manual for further explanations).
///
/// Mode:
/// - 0x0000 = [auto]
/// - 0x0001 = [OFF]
///
/// \param wOffsetRegulation WORD variable to hold the offset mode.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetOffsetMode (WORD wOffsetRegulation);

///
/// \brief Get the temperature set point for cooling the image sensor (only available for cooled cameras).
///
/// If min. cooling set point (in \f$^\circ\f$C) and max. cooling set point (in \f$^\circ\f$C) are zero, then cooling is not available.
/// \param sCoolSet Pointer to a SHORT variable to receive the cooling setpoint temperature.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetCoolingSetpointTemperature(SHORT* sCoolSet);

///
/// \brief Set the temperature set point for cooling the image sensor (only available for cooled cameras).
///
/// If min. cooling set point (in \f$^\circ\f$C) and max. cooling set point (in \f$^\circ\f$C) are zero, then cooling is not available.
/// \param sCoolSet SHORT variable to hold the cooling setpoint temperature in \f$^\circ\f$C units.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetCoolingSetpointTemperature(SHORT sCoolSet);

///
/// \brief Gets the cooling setpoints of the camera.
///
/// This is used when there is no min max range available.
///
/// \param wBlockID Number of the block to query (currently 0)
/// \param sSetPoints Pointer to a SHORT array to receive the possible cooling setpoint temperatures.
/// \param wValidSetPoints WORD Pointer to set the max number of setpoints to query and to get the valid number of set points inside the camera. In case more than COOLING_SETPOINTS_BLOCKSIZE set points are valid they can be queried by incrementing the wBlockID till wNumSetPoints is reached.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetCoolingSetpoints(WORD wBlockID,SHORT* sSetPoints,WORD* wValidSetPoints);


/// @name Recording Control and Status
///
/// This section contains functions to change and retrieve actual recorder settings

///
/// \brief Get storage mode [recorder] or [FIFO buffer].
///
/// \f[
/// \begin{tabular}{| p{7cm} | p{7cm} |}
/// \hline
/// \textbf{Recorder Mode} & \textbf{FIFO Buffer mode} \\ \hline
/// \begin{itemize}
/// \item images are recorded and stored within the internal camera memory camRAM
/// \item Live View transfers the most recent image to the PC (for viewing/monitoring)
/// \item indexed or total image readout after the recording has been stopped
/// \end{itemize}
/// &
/// \begin{itemize}
/// \item all images taken are transferred to the PC in chronological order
/// \item camera memory (camRAM) is used as a huge FIFO buffer to bypass short data transmission bottlenecks
/// \item if buffer overflows, the oldest images are overwritten
/// \end{itemize} \\ \hline
/// \end{tabular}
/// \f]
/// \param wStorageMode Pointer to a WORD variable to receive the storage mode.
/// - 0: Recorder
/// - 1: FIFO
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetStorageMode(WORD* wStorageMode);

///
/// \brief Set storage mode [recorder] or [FIFO buffer].
///
/// \f[
/// \begin{tabular}{| p{7cm} | p{7cm} |}
/// \hline
/// \textbf{Recorder Mode} & \textbf{FIFO Buffer mode} \\ \hline
/// \begin{itemize}
/// \item images are recorded and stored within the internal camera memory camRAM
/// \item Live View transfers the most recent image to the PC (for viewing/monitoring)
/// \item indexed or total image readout after the recording has been stopped
/// \end{itemize}
/// &
/// \begin{itemize}
/// \item all images taken are transferred to the PC in chronological order
/// \item camera memory (camRAM) is used as a huge FIFO buffer to bypass short data transmission bottlenecks
/// \item if buffer overflows, the oldest images are overwritten
/// \item if set recorder = [stop] is sent, recording is stopped and the transfer of the current image to the PC is finished. Images not read are stored within the segment and can be read with the ReadImageFromSegment command.
/// \end{itemize} \\ \hline
/// \end{tabular}
/// \f]
/// \param wStorageMode WORD variable to hold the storage mode.
/// - 0: Recorder
/// - 1: FIFO
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetStorageMode(WORD wStorageMode);

///
/// \brief Get recorder sub mode: [sequence] or [ring buffer] (see explanation boxes below).
///
/// Recorder submode is only available if the storage mode is set to [recorder].
/// \f[
/// \begin{tabular}{| p{7cm} | p{7cm} |}
/// \hline
/// \textbf{recorder sub mode = [sequence]} & \textbf{recorder sub mode = [ring buffer]} \\ \hline
/// \begin{itemize}
/// \item recording is stopped when the allocated buffer is full
/// \end{itemize}
/// &
/// \begin{itemize}
/// \item camera records continuously into ring buffer
/// \item if the allocated buffer overflows, the oldest images are overwritten
/// \item recording is stopped by software or disabling acquire signal (<acq enbl>)
/// \end{itemize} \\ \hline
/// \end{tabular}
/// \f]
/// \param wRecSubmode Pointer to a WORD variable to receive the recorder sub mode.
/// - 0: Sequence
/// - 1: Ring buffer
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetRecorderSubmode(WORD* wRecSubmode);

///
/// \brief Set recorder sub mode: [sequence] or [ring buffer] (see explanation boxes below).
///
/// Recorder sub mode is only available if the storage mode is set to [recorder].
/// \f[
/// \begin{tabular}{| p{7cm} | p{7cm} |}
/// \hline
/// \textbf{recorder sub mode = [sequence]} & \textbf{recorder sub mode = [ring buffer]} \\ \hline
/// \begin{itemize}
/// \item recording is stopped when the allocated buffer is full
/// \end{itemize}
/// &
/// \begin{itemize}
/// \item camera records continuously into ring buffer
/// \item if the allocated buffer overflows, the oldest images are overwritten
/// \item recording is stopped by software or disabling acquire signal (<acq enbl>)
/// \end{itemize} \\ \hline
/// \end{tabular}
/// \f]
/// \param wRecSubmode WORD variable to hold the recorder sub mode.
/// - 0: Sequence
/// - 1: Ring buffer
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetRecorderSubmode(WORD wRecSubmode);

///
/// \brief Get acquire mode: [auto] or [external] (see camera manual for explanation)
///
/// Acquire modes:
/// - 0x0000 = [auto] - all images taken are stored
/// - 0x0001 = [external] - the external control input \<acq enbl\> is a static enable signal of
/// images. If this input is TRUE (level depending on the DIP switch), exposure triggers are
/// accepted and images are taken. If this signal is set FALSE, all exposure triggers are
/// ignored and the sensor readout is stopped.
/// - 0x0002 = [external] - the external control input \<acq enbl\> is a dynamic frame start
/// signal. If this input has got a rising edge TRUE (level depending on the DIP switch), a
/// frame will be started with modulation mode. This is only available with modulation mode
/// enabled (see camera description).
///
/// \param wAcquMode Pointer to a WORD variable to receive the acquire mode.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetAcquireMode(WORD* wAcquMode);

///
/// \brief Set acquire mode: [auto] or [external] (see camera manual for explanation).
///
/// Acquire modes:
/// - 0x0000 = [auto] - all images taken are stored
/// - 0x0001 = [external] - the external control input \<acq enbl\> is a static enable signal of
/// images. If this input is TRUE (level depending on the DIP switch), exposure triggers are
/// accepted and images are taken. If this signal is set FALSE, all exposure triggers are
/// ignored and the sensor readout is stopped.
/// - 0x0002 = [external] - the external control input \<acq enbl\> is a dynamic frame start
/// signal. If this input has got a rising edge TRUE (level depending on the DIP switch), a
/// frame will be started with modulation mode. This is only available with modulation mode
/// enabled (see camera description).
///
/// \param wAcquMode WORD variable to hold the acquire mode.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetAcquireMode(WORD wAcquMode);


///
/// \brief Set acquire mode: [auto] or [external] (see camera manual for explanation).
///
/// Acquire modes:
/// - 0x0000 = [auto] - all images taken are stored
/// - 0x0001 = [external] - the external control input \<acq enbl\> is a static enable signal of
/// images. If this input is TRUE (level depending on the DIP switch), exposure triggers are
/// accepted and images are taken. If this signal is set FALSE, all exposure triggers are
/// ignored and the sensor readout is stopped.
/// - 0x0002 = [external] - the external control input \<acq enbl\> is a dynamic frame start
/// signal. If this input has got a rising edge TRUE (level depending on the DIP switch), a
/// frame will be started with modulation mode. This is only available with modulation mode
/// enabled (see camera description).
///
/// \param wAcquMode Pointer to a WORD variable to receive the acquire mode.
/// \param dwNumberImages Pointer to a DWORD variable to receive the number of images (for mode sequence).
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetAcquireModeEx(WORD* wAcquMode, DWORD* dwNumberImages);

///
/// \brief Get acquire mode: [auto] or [external] (see camera manual for explanation)
///
/// Acquire modes:
/// - 0x0000 = [auto] - all images taken are stored
/// - 0x0001 = [external] - the external control input \<acq enbl\> is a static enable signal of
/// images. If this input is TRUE (level depending on the DIP switch), exposure triggers are
/// accepted and images are taken. If this signal is set FALSE, all exposure triggers are
/// ignored and the sensor readout is stopped.
/// - 0x0002 = [external] - the external control input \<acq enbl\> is a dynamic frame start
/// signal. If this input has got a rising edge TRUE (level depending on the DIP switch), a
/// frame will be started with modulation mode. This is only available with modulation mode
/// enabled (see camera description).
///
/// \param wAcquMode WORD variable to hold the acquire mode.
/// \param dwNumberImages DWORD variable to hold the number of images (for mode sequence).
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetAcquireModeEx(WORD wAcquMode, DWORD dwNumberImages);

DWORD	PCO_GetAcquireControl(WORD* wMode);
DWORD	PCO_SetAcquireControl(WORD wMode);


///
/// \brief Get the current status of the \<acq enbl\> user input (one of the \<control in\> inputs at the rear of pco.power or the camera). See camera manual for more information.
///
/// \b Note:
/// Due to response and processing times e.g. caused by the interface and/or the operating
/// system, the delay between the delivered status and the actual status may be several 10 ms up
/// to 100 ms. If timing is critical it is strongly recommended to use other trigger modes.
/// \param wAcquEnableState Pointer to a WORD variable to receive the acquire enable signal status.
/// - 0x0000 = [FALSE]
/// - 0x0001 = [TRUE]
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetAcqEnblSignalStatus(WORD* wAcquEnableState);




///
/// \brief This command can be used for setting up the record stop event.
///
/// After a stop event the camera records the configured number of images and stops after that. The command is useful to record a
/// series of images to see what happens before and after the stop event.
///
/// A record stop event can be either a software command or an edge at the \<acq enbl\> input (at the
/// power unit). The edge detection depends on the DIP switch setting at the power unit. If the DIP switch shows \f$\rfloor\lfloor\f$
/// then a rising edge is the stop event. If the DIP switch shows \f$\bigsqcup\f$ then a falling edge is the stop event.
///
/// The software command is the command "Stop Record" described below.
///
/// Use the record stop even function only when Storage Mode = [Recorder] and Recorder Sub mode = [Ring buffer]!
///
/// \b Note:
/// - Use the record stop event function only when Storage Mode = [Recorder] and Recorder Sub mode = [Ring buffer]!
/// - Due to internal timing issues the actual number of images taken after the event may differ by +/- 1 from the configured number.
/// - The command is not available for all cameras. It is currently only available on the pco.1200hs. See the descriptor for availability.
///
/// \param wRecordStopEventMode Pointer to a WORD variable to receive the record stop event mode.
///  - 0x0000 = no record stop event is accepted
///  - 0x0001 = record stop by software command
///  - 0x0002 = record stop by edge at the \<acq enbl\> input or by software
/// \param dwRecordStopDelayImages Pointer to a DWORD variable to receive the number of images which are taken after the record stop event. If the number of images is taken, record will be stopped automatically.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetRecordStopEvent(WORD* wRecordStopEventMode,DWORD* dwRecordStopDelayImages);

///
/// \brief This command can be used for setting up the record stop event.
///
/// After a stop event the camera records the configured number of images and stops after that. The command is useful to record a
/// series of images to see what happens before and after the stop event.
///
/// A record stop event can be either a software command or an edge at the \<acq enbl\> input (at the
/// power unit). The edge detection depends on the DIP switch setting at the power unit. If the DIP switch shows \f$\rfloor\lfloor\f$
/// then a rising edge is the stop event. If the DIP switch shows \f$\bigsqcup\f$ then a falling edge is the stop event.
///
/// The software command is the command PCO_StopRecord().
///
/// Use the record stop even function only when Storage Mode = [Recorder] and Recorder Sub mode = [Ring buffer]!
///
/// \b Note:
/// - Use the record stop event function only when Storage Mode = [Recorder] and Recorder Sub mode = [Ring buffer]!
/// - Due to internal timing issues the actual number of images taken after the event may differ by +/- 1 from the configured number.
/// - The command is not available for all cameras. It is currently only available on the pco.1200hs. See the descriptor for availability.
///
/// \param wRecordStopEventMode WORD variable to hold the record stop event mode.
///  - 0x0000 = no record stop event is accepted
///  - 0x0001 = record stop by software command
///  - 0x0002 = record stop by edge at the \<acq enbl\> input or by software
/// \param dwRecordStopDelayImages DWORD variable to hold the number of images which are taken after the record stop event. If the number of images is taken, record will be stopped automatically.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetRecordStopEvent(WORD wRecordStopEventMode,DWORD dwRecordStopDelayImages);

///
/// \brief This command is useful to generate a stop event by software for the record stop event mode. See also PCO_GetRecordStopEvent() and PCO_SetRecordStopEvent().
///
/// If you want to stop immediately please use PCO_SetRecordingState(0).
///
/// \b Note:
/// - Use the record stop event function only when Storage Mode = [Recorder] and Recorder Sub mode = [Ring buffer]!
/// - Due to internal timing issues the actual number of images taken after the event may differ by +/- 1 from the configured number.
/// - The command is not available for all cameras. It is currently only available on the pco.1200hs. See the descriptor for availability.
///
/// \param wReserved0 Pointer to a WORD variable (Set to zero!).
/// \param dwReserved1 Pointer to a DWORD variable (Set to zero!).
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_StopRecord(WORD* wReserved0, DWORD *dwReserved1);

DWORD PCO_GetEventMonConfiguration(WORD* wConfig);
DWORD PCO_SetEventMonConfiguration(WORD wConfig);
DWORD PCO_GetEventList(WORD wIndex,WORD *wMaxEvents,WORD* wValidEvents,WORD* wValidEventsInTelegram,SC2_EVENT_LIST_ENTRY* list);


#endif

//-----------------------------------------------------------------//
// Name        | Cpco_com_func_2.h           | Type: ( ) source    //
//-------------------------------------------|       (*) header    //
// Project     | pco.camera                  |       ( ) others    //
//-----------------------------------------------------------------//
// Platform    | Linux                                             //
//-----------------------------------------------------------------//
// Environment |                                                   //
//             |                                                   //
//-----------------------------------------------------------------//
// Purpose     | pco.camera - Communication                        //
//-----------------------------------------------------------------//
// Author      | MBL, PCO AG                                       //
//-----------------------------------------------------------------//
// Revision    |                                                   //
//-----------------------------------------------------------------//
// Notes       | Telegram functions                                //
//             |                                                   //
//             |                                                   //
//-----------------------------------------------------------------//
// (c) 2010 - 2015 PCO AG                                          //
// Donaupark 11 D-93309  Kelheim / Germany                         //
// Phone: +49 (0)9441 / 2005-0   Fax: +49 (0)9441 / 2005-20        //
// Email: info@pco.de                                              //
//-----------------------------------------------------------------//

//-----------------------------------------------------------------//
// Revision History:                                               //
//  see Cpco_com_func_2.cpp                                        //
//-----------------------------------------------------------------//

#ifndef CPCO_COM_FUNC_2_H
#define CPCO_COM_FUNC_2_H

///
/// \file Cpco_com_func_2.h
///
/// \brief Advanced camera communication
///
/// \author PCO AG
///


/// @name Storage Control and Status
///
/// This section contains functions to change and retrieve actual format settings

///
/// \brief Gets the ram and page size of the camera.
///
/// One page is the smallest unit for RAM segmentation as well as for storing images. Segment
/// sizes can only configured as multiples of pages. The size reserved for one image is also
/// calculated as multiples of whole pages. Therefore, there may be some unused RAM memory
/// if the page size is not exactly a multiple of the image size. The number of pages needed for
/// one image depends on the image size (Xres x Yres) divided by the pixels per page (page size).
/// Every page size that has been started must be considered, so if 50.6 pages are used for an
/// image 51 pages are actually needed for this image. With this value of 'pages per image',the
/// user can calculate the number of images fitting into the segment.
/// \param dwRamSize Pointer to a DWORD variable to receive the total camera RAM.
/// \param wPageSize Pointer to a DWORD variable to receive the pagesize as a multiple of pixels.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetCameraRamSize(DWORD* dwRamSize, WORD* wPageSize);

///
/// \brief Gets the segment sizes of the camera.
///
/// \b Note:
/// - the sum of all segment sizes must not be larger than the total size of the RAM (as multiples of pages)
/// - \b size = [0] indicates that the segment will not be used
/// - using only one segment is possible by assigning the total RAM size to segment 1 and 0x0000 to all other segments.
/// - The segment number is 1 based, while the array dwRamSegSize is zero based, e.g. ram size of segment 1 is stored in dwRamSegSize[0]!
///
/// \param dwRamSegSize Pointer to a DWORD array to receive the ramsegmentsizes in pages.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetCameraRamSegmentSize(DWORD* dwRamSegSize);

///
/// \brief Set Camera RAM Segment Size. The segment size has to be big enough to hold at least two images.
///
/// \b Note:
/// - the sum of all segment sizes must not be larger than the total size of the RAM (as multiples of pages)
/// - a single segment size can have the value 0x0000, but the sum of all four segments must be bigger than the size of two images.
/// - the command will be rejected, if Recording State is [run]
/// - The segment number is 1 based, while the array dwRamSegSize is zero based, e.g. ram size of segment 1 is stored in dwRamSegSize[0]!
/// - This function will result in \b all segments being \b cleared. All previously recorded images will be \b lost!}
///
/// \param dwRamSegSize
/// Pointer to a DWORD array to receive the ramsegmentsize in pages.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetCameraRamSegmentSize(DWORD* dwRamSegSize);

///
/// \brief Get the active camera RAM segment.
///
/// The active segment is where images are stored.
///
/// \param wActSeg Pointer to a WORD variable to receive the actual segment. (1 - 4)
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetActiveRamSegment(WORD* wActSeg);

///
/// \brief Set the active camera RAM segment.
///
/// The active segment is where images are stored.
///
/// \param wActSeg WORD variable to hold the actual segment.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetActiveRamSegment(WORD wActSeg);

///
/// \brief Clear active camera RAM segment, delete all image info and prepare segment for new images.
///
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_ClearRamSegment();

///
/// \brief Get the number of valid images within the segment.
///
/// This function is not applicable with cameras
///without internal recorder memory. The operation is slightly different due to the selected storage mode:
///
/// In [recorder mode], if recording is not stopped and in [FIFO buffer mode] the number of images is
/// dynamic due to read and write accesses to the camera RAM. If the \b camera \b storage \b mode is in
/// [recorder mode] and recording is stopped, the number is fixed.
///
/// In [FIFO buffer] mode the ratio of valid number of images to the maximum number of images is some sort of filling indicator.
/// \param wSegment WORD variable that holds the segment to query.
/// \param dwValid Pointer to a DWORD varibale to receive the valid image count.
/// \param dwMax Pointer to a DWORD varibale to receive the max image count which may be saved to this segment.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetNumberOfImagesInSegment(WORD wSegment,DWORD* dwValid,DWORD* dwMax);

///
/// \brief Get the image settings for images stored into one of the four segments. This function is not applicable with cameras without internal recorder memory.
///
/// Gets the sizes information for one segment.
///
/// X0, Y0 start at 1. X1, Y1 end with max. sensor size.
///
/// \latexonly \begin{tabular}{| l c r | } \hline x0,y0 & & \\ & ROI & \\ & & x1,y1 \\ \hline \end{tabular} \endlatexonly
///
/// \param wSegment WORD variable that holds the segment to query.
/// \param wRes_hor Pointer to a WORD variable to receive the x resolution of the image in segment
/// \param wRes_ver Pointer to a WORD variable to receive the y resolution of the image in segment
/// \param wBin_x Pointer to a WORD variable to receive the horizontal binning of the image in segment
/// \param wBin_y Pointer to a WORD variable to receive the vertical binning of the image in segment
/// \param wRoi_x0 Pointer to a WORD variable to receive the left x offset of the image in segment
/// \param wRoi_y0 Pointer to a WORD variable to receive the upper y offset of the image in segment
/// \param wRoi_x1 Pointer to a WORD variable to receive the right x offset of the image in segment
/// \param wRoi_y1 Pointer to a WORD variable to receive the lower y offset of the image in segment
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetSegmentImageSettings(WORD wSegment,WORD* wRes_hor,WORD* wRes_ver,WORD* wBin_x,WORD* wBin_y,WORD* wRoi_x0,WORD* wRoi_y0,WORD* wRoi_x1,WORD* wRoi_y1);


/// @name Image transfer
///
/// This section contains functions to invoke image transfers from the camera

///
/// \brief  Reads the specified images from segment.
///
/// \param wSegment WORD variable that holds the segment to query.
/// \param dwStartImage DWORD variable that holds the first image to receive.
/// \param dwLastImage DWORD variable that holds the last image to recieve.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_ReadImagesFromSegment(WORD wSegment,DWORD dwStartImage,DWORD dwLastImage);


///
/// \brief Requests a single image from the camera.
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_RequestImage();

///
/// \brief Repeats the last image.
///
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_RepeatImage();

///
/// \brief PCO_CancelImage
///
/// Cancels the image transfer.
///
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_CancelImage();


///
/// \brief Cancels the image processing.
///
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_CancelImageTransfer();

///
/// \brief Gets the image transfer mode
/// Get the current active transfer mode and the additional parameters for this mode
///
/// \param wMode Pointer to WORD variable to receive the image mode. (e.g. full, scaled, cutout etc.)
/// \param wImageWidth Pointer to WORD variable to receive the original image width
/// \param wImageHeight Pointer to WORD variable to receive the original image height
/// \param wTxWidth Pointer to WORD variable to receive the transferred image width
/// \param wTxHeight Pointer to WORD variable to receive the transferred image height
/// \param wTxLineWordCnt Meaning depends on selected mode
/// \param wParam Meaning depends on selected mode
/// \param wParamLen Pointer to WORD variable to receive wParam length.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetImageTransferMode(WORD* wMode,WORD* wImageWidth,WORD* wImageHeight,WORD* wTxWidth,WORD* wTxHeight,WORD* wTxLineWordCnt,WORD* wParam,WORD* wParamLen);

///
/// \brief Sets the image transfer mode
/// Set the current transfer mode and the additional parameters for this mode
/// This function offers the ability to reduce the amount of image data, which is transferred through the interface.
/// It can be used to offer an quick preview of all images stored in the camera.
///
/// \param wMode WORD variable to set the image mode. (e.g. full, scaled, cutout etc.)
/// \param wImageWidth WORD variable to set the original image width
/// \param wImageHeight WORD variable to set the original image height
/// \param wTxWidth WORD variable to set the scaled/cutout image width
/// \param wTxHeight WORD variable to set the scaled/cutout image height
/// \param wTxLineWordCnt Meaning depends on selected mode
/// \param wParam Meaning depends on selected mode
/// \param wParamLen WORD variable to hold the wParam length.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetImageTransferMode(WORD wMode,WORD wImageWidth,WORD wImageHeight,WORD wTxWidth,WORD wTxHeight,WORD wTxLineWordCnt,WORD* wParam,WORD wParamLen);




/// @name Image data options
///
/// This section contains functions to change and retrieve actual settings for the transferred image data


///
/// \brief Gets infos about lookup tables in the camera, if available.
///
/// Only available with a pco.edge.
///
/// \param wLUTNum WORD variable to hold the number of LUT to query.
/// \param wNumberOfLuts Pointer to WORD variable to recieve the number of LUTs which can be queried
/// \param Description Pointer to string to recieve the description, e.g. "HD/SDI 12 to 10".
/// \param wDescLen Pointer to WORD variable to recieve the string length.
/// \param wIdentifier Pointer to WORD variable to recieve the loadable LUTs. Range from 0x0001 to 0xFFFF
/// \param bInputWidth Pointer to BYTE variable to recieve the maximum input in bits.
/// \param bOutputWidth Pointer to BYTE variable to recieve the maximum output in bits.
/// \param wFormat Pointer to WORD variable to recieve the accepted data structures (see defines!)
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetLookupableInfo(WORD wLUTNum, WORD* wNumberOfLuts, char* Description,WORD wDescLen,WORD* wIdentifier, BYTE* bInputWidth,BYTE* bOutputWidth, WORD* wFormat);


///
/// \brief Gets the active lookup table in the camera, if available.
/// 
/// Only available with a pco.edge
/// \param Identifier Currently active LUT, 0x0000 for no LUT
/// \param Parameter Offset: 11 Bit value for fixed offset subtraction before transferring the data via the lookup table
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_GetLut(WORD *Identifier,WORD *Parameter);


///
/// \brief Sets the active lookup table in the camera, if available.
/// 
/// Only available with a pco.edge
/// \param Identifier define LUT to be activated, 0x0000 for no LUT, see PCO_GetLookupTableInfo() for available LUTs
/// \param Parameter Offset: 11 Bit value for fixed offset subtraction before transferring the data via the lookup table
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_SetLut(WORD Identifier,WORD Parameter);

///
/// \brief Gets the actual bit alignment of the raw image data.
///
/// Since the image data is less than a WORD, which is 16 bit, the data can be placed in two reasonable ways.
/// Either you set the LSB of the image data to the LSB of the transferred data or
/// you set the MSB of the image data to the MSB of the transferred data.
///
/// \param align Pointer to a WORD variable to receive the bit alignment.
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_GetBitAlignment(WORD *align);

///
/// \brief Sets the actual bit alignment of the raw image data. See PCO_GetBitAlignment() for details.
/// 
/// Set the following parameter:
/// - wBitAlignment:
///   - 0x0000 = [MSB aligned]; all raw image data will be aligned to the MSB. This is the default setting.
///   - 0x0001 = [LSB aligned]; all raw image data will be aligned to the LSB.
///
/// \param align WORD variable which holds the bit alignment.
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_SetBitAlignment(WORD align);

///
/// Get mode of the timestamp function.
///
/// The input pointer will be filled with the following parameter:
/// - 0x0000 = no stamp in image
/// - 0x0001 = BCD coded stamp in the first 14 pixel
/// - 0x0002 = BCD coded stamp in the first 14 pixel + ASCII text
/// - 0x0003 = ASCII text only (see descriptor for availability)
///
/// \param mode Pointer to a WORD variable to receive the time stamp mode.
/// See PCO_SetTimestampMode() for a detailed explanation.
/// \return Error code
///
DWORD PCO_GetTimestampMode(WORD *mode);

///
/// Set mode of the timestamp function.
///
/// To obtain information about the recording time of images this command can be useful. It writes a
/// continuous image number and date / time information with a resolution of 10 \f$\mu\f$s direct into the
/// raw image data. The first 14 pixels (top left corner) are used to hold this information. The
/// numbers are coded in BCD with one byte per pixel, which means that every pixel can hold 2
/// digits. If the pixels have more resolution as 8 bits, then the BCD digits are left bound adjusted and
/// the lower bits are zero. Additionally to this 14 pixels, the information can be written in ASCII text
/// for direct inspection. An 8 by 8 pixel array is used per ASCII digit. The digits are displayed below the BCD coded line.
///
/// The input data should be filled with the following parameter:
/// - 0x0000 = no stamp in image
/// - 0x0001 = BCD coded stamp in the first 14 pixel
/// - 0x0002 = BCD coded stamp in the first 14 pixel + ASCII text
/// - 0x0003 = ASCII text only (see descriptor for availability)
///
/// \b Note:
/// - the image number is set to value = [1], when an arm command is performed
/// - using this command without setting the [date] / [time] results in an error message
///
/// Format of BCD coded pixels:
/// Pixel 1 | Pixel 2 | Pixel 3 | Pixel 4 | Pixel 5 | Pixel 6 | Pixel 7 |
/// --------|---------|---------|---------|---------|---------|---------|
/// image counter (MSB) (00...99)  | image counter (00...99)  | image counter (00...99) | image counter (LSB) (00...99) | year (MSB) (20) | year (LSB) (15...99) | month (01...12) |
///
/// Pixel 8 | Pixel 9 | Pixel 10 | Pixel 11 | Pixel 12 | Pixel 13 | Pixel 14 |
/// --------|---------|---------|---------|---------|---------|---------|
/// day (01...31) | h (00...23) | min (00...59) | s (00...59) | \f$\mu\f$s * 10000 (00...99) | \f$\mu\f$s * 100 (00...99) | \f$\mu\f$s (00...99) |
/// \param mode WORD variable to hold the time stamp mode.
/// \return Error value or 0 in case of success
///
DWORD PCO_SetTimestampMode(WORD mode);

///
/// \brief Get the Hot Pixel correction mode.
///
/// This command is optional and depends on the hardware and firmware. Check the availability according to the camera descriptor (HOT_PIXEL_CORRECTION).
/// Mode:
/// - 0x0000 = [OFF]
/// - 0x0001 = [ON]
///
/// \param wHotPixelCorrectionMode Pointer to a WORD variable to receive the hot pixel correction mode.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetHotPixelCorrectionMode (WORD* wHotPixelCorrectionMode);

///
/// \brief Get the Hot Pixel correction mode.
///
/// This command is optional and depends on the hardware and firmware. Check the availability according to the camera descriptor (HOT_PIXEL_CORRECTION).
/// Mode:
/// - 0x0000 = [OFF]
/// - 0x0001 = [ON]
///
/// \param wHotPixelCorrectionMode Pointer to a WORD variable to receive the hot pixel correction mode.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetHotPixelCorrectionMode (WORD wHotPixelCorrectionMode);

///
/// \brief Gets the metadata mode
///
/// his command is optional and depends on the hardware and firmware. Check the availability
/// according to the camera descriptor (METADATA). Gets the mode for meta data. See
/// PCO_GetMetaData() (dimax only) for more information.
///
/// When wMode is set to 1, the user is responsible to add further
/// line(s) to the buffers, where the number of lines depends on x-resolution and needed wMetaDataSize.
///
/// \param wMode Pointer to a WORD variable receiving the meta data mode.
///  - 0x0000: [OFF]
///  - 0x0001: [ON]
/// \param wMetadataSize Pointer to a WORD variable receiving the meta data block size in additional pixels.
/// \param wMetadataVersion Pointer to a WORD variable receiving the meta data version information.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_GetMetadataMode(WORD* wMode,WORD* wMetadataSize,WORD* wMetadataVersion);

///
/// \brief Sets the meta data mode
///
/// This command is optional and depends on the hardware and firmware. Check the availability
/// according to the camera descriptor (METADATA). Sets the mode for meta data. See
/// PCO_GetMetaData() (dimax only) for more information.
/// When wMetaDataMode is set to 1, the user is responsible to add further
/// line(s) to the buffers, where the number of lines depends on x-resolution and needed wMetaDataSize.
///
/// This option is only available with pco.dimax
///
/// \param wMode WORD variable to set the meta data mode.
///  - 0x0000: [OFF]
///  - 0x0001: [ON]
/// \param wMetadataSize Pointer to a WORD variable receiving the meta data block size in additional pixels.
/// \param wMetadataVersion Pointer to a WORD variable receiving the meta data version information.
/// \return Error message, 0 in case of success else less than 0.
///
DWORD PCO_SetMetadataMode(WORD wMode,WORD* wMetadataSize,WORD* wMetadataVersion);


/// @name Hardware Input/Output options
///
/// This section contains functions to change and retrieve actual settings for Input and output connectors


///
/// \brief Gets the number of available HW signals. Not applicable to all cameras.
/// 
/// Get the number of hardware IO signals, which are available with the camera. To set and get the
/// single signals use PCO_GetHWIOSignal() (dimax, edge only) and PCO_SetHWIOSignal() (dimax,
/// edge only). This functions is not available with all cameras. Actually it is implemented in the pco.dimax.
/// \param numSignals WORD variable to get the number of signals
/// \return Error message, 0 in case of success else less than 0
///
DWORD PCO_GetHWIOSignalCount(WORD *numSignals);

///
/// \brief Gets the signal descriptor of the requested hardware IO signal. Not applicable to all cameras.
/// 
/// To get the number of available hardware IO signals, please call PCO_GetHWIOSignalCount() (dimax edge only). To set and get the single
/// signals use PCO_GetHWIOSignal() (dimax, edge only) and PCO_SetHWIOSignal() (dimax, edge only).
/// This functions is not available with all cameras. Actually it is implemented in the pco.dimax.
///
/// The output structure has the following parameters:
/// - wSignalDefinitions: Flags showing signal options:
///   - 0x01: Signal can be enabled/disabled
///   - 0x02: Signal is a status output
///   - 0x10: Signal function 1 has got parameter value
///   - 0x20: Signal function 2 has got parameter value
///   - 0x40: Signal function 3 has got parameter value
///   - 0x80: Signal function 4 has got parameter value
/// - wSignalTypes: Flags showing which signal type is available:
///   - 0x01: TTL
///   - 0x02: High Level TTL
